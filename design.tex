
\section{Design}

FOKS is a classic client-server system. At a hight level, the clients
manage private keys, and the server manages public keys, encryptions of, 
shared secret keys, and encrypted data. Users generally trust their
servers to be online, available and not to intentionally sabotage
agreed-upon protocols. 

\subsection{System Architecture}

Much like HTTP or STMP, FOKS clients communicate with one or more servers,
depending on where users have accounts. They can safely ignore the other servers
in the system. Most communication is between client and server, and there is
little if any server-to-server or client-to-client communication.  This
property simplifies protocol upgrades and network configuration.

Each client can speak for many users, as users can have accounts on different
servers, or several accounts on the same server. By analogy, an email client can
server multiple emails accounts for the same user concurrently, say one for work
and one for personal use. Or a web browser might have different personae (with
different cookies, preeferences, passwords and history) for the same user.

Each of the users can of course have multiple devices, like a desktop, a laptop,
a phone, and a \yubi . Additionally, users can have "backup devices", which can
be writted down on paper and stored in a safe place. The system recommends at
least two devices to prevent data loss. That is, these devices have private keys
that decrypt data, and the loss of the last key prevents decryption of the data.
Obviously there is a trade-off here: the more devices, the more likely the user
will lose one, or have one stolen; the fewer devices, the more likely the user
will lose all devices and therefore access to data. Some optimal middle ground
exists, but varies with the users and their behaviors. 

\subsection{Key Hierarchy}

The FOKS key hierarchy sits at the core of the system. It aims to provide users
with a sequence of symmetric keys shared across all of their devices, so that
they can store data encrypted with the latest key, and can decrypt (and
authenticate) data encrypted with older keys when necessary. Similarly, users in
a team should share secret keys that users outside their teams cannot see, allowing
them to share encrypted data via untrusted FOKS servers.

\subsubsection{Device Keys}

When a user sits down at a FOKS client to signup or provision a new device
for an existing account, she first creates a new key-pair specifically
for that device. The private key never leaves the device. She shares the public key
with the FOKS server, who eventually selectively shares it with user users.
We detail the exact cryptography in Section~\ref{sec:cryptography}.

Hardware keys that support the PIV protocol (like \yubi{} version 5 and later)
can also be used as device keys. These devices get randomly-generated private
keys in the factory, written to one of 20 possible "slots." FOKS users select
a slot to use, and the client sends the corresponding public key to the FOKS 
server. Signing and decryption operations happen on the device against the chose
slot. 

\subsubsection{Per-User Keys (PUKS)}

Every user on the FOKS system has one of more per-user keys, or PUKS. A PUKS
is a randomly-generated key-pair whose private key is encrypted for each of
the device public keys. This way, all current devices can access the current
PUK secret key, and perform decryptions or signatures for the current PUK public
key. The client makes a new PUK every time the user revokes a device. The system
encrypts the old PUK secret keys for the new PUK secret key. This way,
a device that has access to the latest PUK can get access easily to all prior
PUKs.

Once the PUK sequence is estblished, the system has a convenient way to encrypt
a data for all of the user's device --- it simply encrypts the data for the 
user's latest PUK.

\subsubsection{Per-Team Keys (PTKs)}

Each team has a sequence of per-team-keys, or PTKs, which are analogous
to PUKs for users. Upon creation, a team gets a new random PTK. The 
client performing the creation sends the public part of the PTK to the server.
The private part of the PTK is encrypted for each member's latest PUK,
and therefore is available on each of the user's devices.

As with PUKs, data that the team shares is encrypted for the team's latest PTK,
and all members can decrypt it. As we will see in Section~\ref{sec:teams}, teams can
join other teams, but the key hierarchy works just the same. When team $A$ joins
team $B$, the secret part of team $B$'s PTK is encrypted for team $A$'s latest PTK,
so that all members of team $A$ can decrypt $B$'s PTK, and therefore, all of
$B$'s encrypted data.

\subsection{Key Roles}

\newcommand{\owner}{\textsf{owner}}
\newcommand{\admin}{\textsf{admin}}
\newcommand{\reader}{\textsf{reader}}
\newcommand{\none}{\textsf{none}}
\newcommand{\role}[1]{\textsf{role}(#1)}


FOKS has a notion of a ``role'' for device keys, PUKs and PTKs. The roles
are: \owner, \admin, and \reader, but \reader{} keys have a "visibility level"
that varies between -32768 and 32767. There is a total ordering among key roles,
so that $\owner > \admin > \reader$, and between reader keys, $k_1 > k_2$ iff
$k_1$ has a higher visibility level than $k_2$.

The important property enforced is that we only encrypt PUK $k$ for device key
$j$ if $\role{k} \le \role{j}$, and similarly, we only encrypt PTK $k$ for PUK
$j$ if $\role{k} \le \role{j}$.

The idea here is that the owners of a group get to see all the keys; the admins
can see the admin and reader keys; and the readers can see keys at or below
their visiblility level. This configuration allows groups to have
lower-privileged members, and for users to have lower-privileged devices. At
Keybase, a similar but less-flexible property allows ``bots'' into teams, so that
all the members of the teams can interact with the bots, but the members had
channels to communicate that the bots aren't privvy to.  For now, all user
devices are at the \owner{} role, but we plan to relax this requirement in the
future.

\subsection{Data Structures}

We now have some basic motivation as to what the key system ought to achieve.
It ought to allow groups of devices, groups of users, or groups of users
and teams to share a secret encryption key. From there, they can share data
encrypted (and authenticated) with that key. But the question becomes,
how are users formulated from devices, and how are teams formulated from users
so that only desired members are in the group, especially if the server
behave maliciously?

For instance, a malicious server might fool a user into encrypting secret data
for an invalid device, or team administrator into encrypted data for an invalid
user.

\subsubsection{Signature Chains}
\label{sec:sigchains}

FOKS uses the same mechanism as Keybase here --- the signature chain (or
``sigchain'' for short).  The sigchain is a series of signed statements that
form a cryptographic chain, meaning they can only be replayed in the intended
order. Replaying the chain allows a viewer to confirm the chain appears how the
author intended and wasn't tampered with, even if the set of signers varies over
time. Of course, signers do vary over time as users add and remove devices, or
as they add and remove members from teams.

Each user (and team) gets its own sigchain. The sigchain keeps an indellable record
of which keys can update the chain, and which PUKs or PTKs are currently
active for the user (or team).

\paragraph{Users} The first link in a sigchain is called the ``eldest'' link. For user sigchains,
the first device generates this link, generates the first PUK, and then computes
a signature over the following data:

\begin{enumerate}[label=U.\arabic*]\itemsep0em
    \item \label{item:prev} The hash of the previous link in the chain (nil for the eldest)
    \item The current sequence number of the sigchain (which is 1 for the eldest link)
    \item A commitment to the next random tree location (see Section~\ref{sec:location-hiding})
    \item The current Merkle root hash (see Section~\ref{sec:merkle})
    \item The user's ID and the server's host ID (see Section~\ref{sec:hostchains})
    \item \label{item:puk} The user's new PUK public keys
    \item The user's new device key
    \item A ``subchain tree location seed commitment`` (see Section~\ref{sec:subchains})
      \label{item:stlsc}
    \item A cryptographic commitment to the user's username (see Section~\ref{sec:naming})
       \label{item:name}
    \item A cryptographic commitment to the user's device name (picked by the user)
    \item The role of the new device (currently always \owner ).
    \item For \yubis , a public ``subkey' (see Section~\ref{sec:authentication})
\end{enumerate}

The client computes nested signatures first by the new PUKs introduced in
Step~\ref{item:puk}, and lastly by the user's device key. (Recall that sometimes
several PUKs can be introduced at once due to the different possible device
roles). The client uploads the whole package as the user's eldest link.

Subsequent links proceed in largely the same way, with a few minor differences.
The previous hash (\ref{item:prev}) is the collision-resistent hash of the 
package uploaded in the previous step. In some cases, like device addition,
new PUK public keys (\ref{item:puk}) do not appear. In these cases,
no signatures with PUKs are required.

For any link in the chain, a set of devices is authorized to make further
updates to the chain. After the first link, the set contains only the first
device (sometimes called the ``eldest`` device). A link can either add a new
device, or revoke an existing device, updating the set of authorized devices
accordingly. When clients upload new chainlinks, the server enforces valid
signatures by authorized devices. When users replay this chain, they perform the
same check. This simple mechanism ensures the server can't introduce a bogus
device.

\paragraph{Teams} A team chain link contains the following fields, many of which
are analagous to user chains:

\begin{enumerate}[label=T.\arabic*]\itemsep0em
    \item The hash of the previous link in the chain (nil for the eldest)
    \item The current sequence number of the sigchain (starting at 1)
    \item A commitment to the next random tree location
      \label{item:next-tree-location}
    \item The current Merkle root hash 
    \item The team's ID and the server's host ID
    \item The user (or team) ID, host ID, and PUK (or PTK) of the actor making the change
       \label{item:team-actor}
    \item New PTK public keys
    \item \label{item:membership} A set of membership changes
    \item A ``subchain tree location seed commitment``
    \item A cryptographic commitment to the team's name (optional if not changing)
    \item The team's ``index range'' (see~\ref{sec:team-index-range})
\end{enumerate}

Since teams can contain both users and other teams, the actor creating or
modifying the team can be either a user or a team. In FOKS, a \textit{party}
refefes to someone or something that can be in a team, so either a user or a
team. In field~\ref{item:team-actor}, the link contains the unique identifier of
the party (which is the user or team ID plus the host ID), and also the key
making the change. For users, this key is the user's latest PUK at the \owner{}
role.  For teams, it's the team's latest PTK at the desired source role. That
is, consider a teams $T$  where users $a$ and $b$ are owners of $T$, $c$ is an
admin and $d$ is a reader (at visibility level 0). If $T$ creates a new team $U$
with source role of \owner, then only users $a$ and $b$ will have access. If
$T$ creates the new team with source role of \reader, then all users will have
access. 

FOKS clients and servers enforce these access controls with the key hierachy.
In the case of the owners of $T$ creating $U$, $T$'s \owner{} PTK appears in
field~\ref{item:team-actor} and performs the signature over the chainlink. 
As $T$ creates $U$, it makes new PTKs for $U$. It encrypts the secret keys
of these new PTKs for the \owner{} PTK of $T$. This way, everyone in the owner
group of $T$ can now access $U$'s PTKs. The second example follows similarly,
with the readers of $T$ getting access to $U$'s secret PTKs after team creation.

The membership changes field (\ref{item:membership}) contains the following
fields for each member being modified:

\begin{enumerate}[label=M.\arabic*]\itemsep0em
    \item The ``destination role'': the role the member is to have in the team; for removals,
      this is the role \none .
      \label{item:dst-role}
    \item The member's party and host IDs (a party ID is a user ID or a team ID).
      \label{item:party-id}
    \item The source role: the role the member has in its current party.
    \item The member's public PTK or PUK from its current party.
      \label{item:team-member-ppk}
    \item The generation number of that PTK or PUK.
    \item A commitment to a ``team removal key'' (see Section~\ref{sec:removal-keys})
\end{enumerate}

In the case of team creation, member addition, member role upgrade or downgrade, the
role in field~\ref{item:dst-role} is the new role in the target team that the member
has after the change is applied.  In the case of removal, the role is \none. 

Note that in field~\ref{item:team-member-ppk}, the public PUK (or PTK) appears directly
in the chain, in addition to the ID of that party. Admins and owners are later allowed to
make team modifications, and these are the public keys that will sign these modifications.
Team readers in particular might lack the permission to load the chains of these users
and teams directly, so it's crucial the keys appear directly in the team chain. 
See Section~\ref{sec:sigchain-viz} for further details about sigchain visibility.

As alluded to above, owners have ultimate control over the team. They can add and remove
members, add other owners, downgrade owners to admins, etc. Admins have more limited 
control; the have similar control over admins and readers, but cannot: upgrade admins
to owners, introduce new members as owners, remove existing owners; or downgrade 
existing owners. Readers cannot make any team modifications but can of course read
team chains, and can access data protected by the reader's PTKs at their level
and below.

Teams, unlike users, can include members located on different servers. Above, in 
item~\ref{item:party-id}, we include the host ID of the party in the membership change.
Remote members cannot be admins or owners, but can be readers. This configuration allows
for convenient data sharing across federation boundaries, but simplifies team management
relative to an alternative system where remote members can be owners or admins.

Parties making changes to team sign new team chain links much the same way as user devices
sign user chain links. First, all new PTKs sign the chain link, and then the acting
party's latest PUK or PTK signs the chain link. This PUK or PTK must be the exact key
advertised earlier in the chain in the case of link 2 and above. The eldest link
is essentially self-signed.

\subsubsection{Sigchain Playback}

Whenever a client on the time interacts with another party, or even itself, it
begins by playing back that party's sigchain. The client connects to the party's home
server, downloads any new links it hasn't seen, and ensures the new links play back
cleanly on top of links it previously cached. The rules for playback are largely
implied by the discussion above, such as:

\begin{itemize}\itemsep0em
    \item All chains start at 1, and have ascending sequence numbers.
    \item All links should contain the hash of the previous link.
    \item All links should have valid signatures by devices, PUKs or PTKs that the chain 
      itself authorized. Eldest links are essentially self-signed.
    \item The role restrictions described in Section~\ref{sec:sigchains} are obeyed in team chains.
\end{itemize}

Once playback succeeds, the client has a set of devices keys, PUKs and PTKs that can
speak on behalf of the party. It also has rosters of devices of members who share that
key. From here, useful application work can take over. For instance, in the case
of file sharing (whether via Git or via a KV-store interface), a key derived from the
most recent PUK or PTK serves as the symmetric key for authenticated encryption. 
Whenever the PUK or PTK rotates to a new generation, future encryption should use the
new key.

\subsubsection{Merkle Tree}
\label{sec:merkle}

Section~\ref{sec:threatmodel} describes the FOKS threat model, and we assume the
server can behave maliciously.  Sigchains prevent a server from creating new
chainlinks out of whole cloth and interleaving those with legitimate links. The
protection simply is that the server does not have the private keys the parties
use for signing. We assume those never leave the devices they are made on. By these 
mechanisms, the server cannot extend a chain or replace an inner link. The server can
of course create a brand new chain, and might attempt clients into using this chain
rather than the one the users intended. This case of "mistaken identity" is one
of \textit{naming}, which we cover in Section~\ref{sec:naming}.

The server can nonetheless \textit{withhold} links at the end of a chain, 
or show some clients the full chains, and other various subchains, with the
hope of forcing them to ``fork'' the sigchain into 2 incompatible directions.
We need a mechanism to force the server's hand into showing a consistent 
chain tail to all users who request it. This is where the Merkle tree
comes in. FOKS servers expose a Merkle Tree that forces the server to commit
to a coherent state of the system, across all parties, preventing selective
rollback of sigchains. 

FOKS uses a Merkle Tree strategy that is a hybrid of Keybase's~\cite{keybase},
CONIK's~\cite{melara2015coniks} and SEAMLess's~\cite{chase2019seemless}, but
with a simple novel mechanism introduced to obviate the need for pseudo-random
functions. The Merkle tree stores each party's sigchain tail at a leaf 
in the Merkle tree. The server computes hashes all the way up to the root node.
The \textit{root block} contains this tree root hash, a pointer to the previous version of
the tree (called the previous ``epoch''), a logarithmicly-sized set of pointers
to previous roots further back in history, and also the tail of the 
server's hostchain (see Section~\ref{sec:hostchains}). The hash of this
root block is now a summary of the entire system. The server attempts to publish
root blocks immediately after every sigchain update, but sometimes batches 
them for efficiency. In general, roots should be produced no more than
15 seconds after a sigchain update to keep clients responsive (since sometimes
they need to wait for updates).

\subsubsection{Root Chaining}

Since many users and teams might be active on a signle FOKS server, 
the user has no reason to download every root Merkle epoch. Rather,
the user will experience long gaps between epochs, especially if going
periodically offline. Whenenever a client downloads a root block,
say at epoch $i$, it writes it to local storage. When the client later
downloads another root block, call it $k$, the client enforces
that $i < k$. It also sends up the paremeter $i$, and the server
replies with intermediate blocks $j_1, j_2 \dots j_n$, such that
$i < j_1 < \cdots j_n < k$,  where block $j_{a}$ contains
a pointer to $j_{a-1}$, block $j_1$ contains a pointer to $i$
and block $k$ contains a pointer to $j_n$. The spacing of the
previous pointers in the root block ensures than $n$ is appromixately
$\log (k-i)$. Chaining root blocks in this way 
encourages the server to maintain a consistent, coherent append-only
tree. Clients should perform periodic audits of all root blocks
to ensure previously pointer consistency across all epochs.

\subsubsection{Location Hiding}
\label{sec:location-hiding}

For the party $p$, at sequence number $i$, the leaf node is a key-value pair,
where the key is $H(p,i,t,r_i)$, and the value is the hash of the signature of
the last link in the sigchain (the $i$th). $t$ is an enumerated value that
specifies which type of chain for $p$ this is. As we will see in 
Section~\ref{sec:subchains}, each party has multiple chains.  $r_i$ is a random
value that was generated when the $(i-1)$ link was published. The $(i-1)$ link
contains the value $H(r_i)$ in the field~\ref{item:next-tree-location} from
Section~\ref{sec:sigchains}. This simple mechanism achieves the same end as the
PRF in CONIKs and SEAMLess, in that it's unpredictable in the tree where a
team's sighcains is stored. This unpredictability prevents data leaks that would
otherwise allow the owners of neighboring nodes in the tree to deduce when $p$'s
chain advances. 

When a client requests a sighchain for party $p$, the server returns $(n+1)$
paths down from the root of the tree, if the sigchain is $n$ links long. The
first $n$ paths point to chain links 1 through $n$ as described above, and the
last is a proof that the $(n+1)$ link does not exist. For each path, the server
returns neighbors necessary to trace the path back to the tree root. The server
also returns the sequence $(r_2, r_3, \dots r_{n+1})$, so the client can verify
they match the commitments in the sigchain.  Note the first link location is not
randomized with $r_1$, since there was no $0$th link to commit to $r_1$.
However, the eldest link's placements is already essentially random since the
party's ID $p$ is generately randomly at the first link (and is predictable
thereafter).


\subsubsection{Hostchains}
\label{sec:hostchains}

Servers maintain hostchains so they can manage and rotate their signig keys, DNS names,
and TLS keys. Like team and user chains, hostchains form a cryptographic chain, ensuring
they can only be replayed in the intended order, even if modified in transit. Chain links
have sequence numbers and contain the cryptographic hashes of previous links. When an
administrator creates a new server, they first create a \textit{hostkey}, a signing key-pair.
This public key becomes the host's ID. The first chainlin contains this hostkey and several
subkeys, one that serves as a TLS CA for the server, and one used to sign \textit{zonefiles}
for the server. The \textit{zonefile} contains the DNS names for the server's various services
(see Section~\ref{sec:foks-server}). Subsequent chainlinks can change any of these keys
or subkeys, as long as they are signed with keys valid up until that point. clients
play these links back to map host IDs to DNS names as they establish connections
to new servers. 


\subsubsection{Subchains}
\label{sec:subchains}

\newcommand{\user}{\textsf{user}}
\newcommand{\settings}{\textsf{settings}}
\newcommand{\teamMembership}{\textsf{teamMembership}}

\paragraph{User Settings}
We have already seen two sigchains: the user chain and the team chain. Each of
these chains has a subchain. Users have a \textit{user settings subchain} in
addition to the user chain. Currently, this chains contains information about
the user's passphrase, which can optionally be used to locally encrypt device
keys (see Section~\ref{sec:passphrase}). Whenever the user changes her
passphrase, she writes a new link to the chain, so that the server cannot roll
back her passphrase information to an earlier setting.  Chain locations for
links $i_2$ and above are computed as in the user chain itself, but with $t =
\settings$ rather than $t = \user$.  However, the eldest link is randomized,
since otherwise, its location in the tree is predictable given the user ID.

Recall that the eldest user chain link contains a ``subchain tree location seed
commitment``(\ref{item:stlsc}). When creating the link, the client software
generates a random valaue $s$, and puts the hash $H(s)$ into the chain link.
Then $r_1 = H(s, \settings)$, and the Merkle Tree stores the first link of 
$u$'s user settings chain at location $H(u, 1, \settings, r_1)$. The server knows 
$s$, and $u$ knows $s$, so both can compute and verify the random location of 
the first link of the user settings chain. But other users who view $u$'s
sigchain do not know $s$ and therefore cannot infer if $u$ has a user
settings chain or not.

\paragraph{Team Membership} Users and teams have a subchain to keep track
of which team it is a member of. As we discuss in Section~\ref{sec:clkr},
users need to rotate their teams from time to time based on key rotation
events, like device revocation and removals from teams. The general strategy
the user follows is to enumerate all teams she is transitively a member
of (since recall teams can be members of other teams), and then check
each team for staleness, rotating those that are stale. If this membership
list were based purely on server trust, a malicious server could withhold
team memberships from a user to silent suppress team rotations.\footnote{
    A malicious server could also reject a legitimate team update, but the user's
    software can alert the user of such a failure.
} Instead of relying on server trust, the client software maintains a list
of team memberships as a sigchain, which the server must faithfully
synchronize across all of the user's devices. The tree location
mechanism here is the same as for user chains, with $t = \teamMembership$.
See Section~\ref{sec:removal-keys} for more information on team additions
and removals, and how the client maintains this subchain.

\subsubsection{Naming}
\label{sec:naming}

The server stores user and team chains at tree locations indexed by user IDs
and team IDs respectively. These IDs are large random identitiers, and are not
friendly to humans. Users of course need to be able to refer to these parties
with convenient names. Morever, parties should have the ability to change
names from time-to-time, though not too frequently, as too much churn in naming would
complicate the user experience. 

Naming in FOKS works as follows. When a user signs up, she first picks a name
$n$, and the software later generates a random user ID $u$ that n will
correspond to. The server stores the user ID $u$ at the Merkle Tree
location $H(n, 1, \textsf{name}, nil)$, and the sigchain for $u$
commits to $n$ at~\ref{item:name}. When another user loads $u$, she
looks up the Merkle leaves at location $H(n, 1, \textsf{name}, nil)$
and $H(n, 2, \textsf{name}, nil)$, confirming that the first location
maps to $u$, and that the second location is absent from the tree,
confirming the name hasn't be remapped. The loader then confirms
that the name matches the commitment in $u$'s sigchain. 

This system ensures a 1-to-1 mapping between a name $n$ and a
user ID $u$. $u$ can later switch to a new name $n'$ by adding
another sigchain link commiting to $n'$ that overrides the earlier
commitment to $n$. The server can likewise later reassign $n$
(though we currently do not allow this) by posting a new user ID
$u'$ at tree location $H(n, 2, \textsf{name}, nil)$.

Team naming works exactly the same way.

\subsection{Provisioning}

When users sign up for a new FOKS account, they establish a first device. They
establish further devices via a process called ``provisioning''. In
provisioning, an existing device signs the device key of the new device, and
also sends it the private side of the current PUK. As we saw above, the
signatures form a link in the sigchain. The server helps exchanged encrypted PUK
keys as ``sidecar'' data.

\subsubsection{Device-to-Device}
\label{sec:kex}

The most complicated case is device-to-device provisioning. A user has an
active account on device $D_1$ and uses it to directly provision device $D_2$.
We call the existing device, $D_1$, the ``provisioner'', and the new device, $D_2$,
the ``provisionee.''
Device $D_2$ generates a new device key $k_2$ and prompts the user for
a device name, which is $n_2$.
Both devices pick random 125-bit session keys, call them $s_1$ and $s_2$. Both clients
show these keys to the user, using a simple encoding scheme we call
``high-entropy secret phrase''. See Section~\ref{sec:hesp} for more details.
An example might look like:\footnote{The \texttt{foks} client
running \texttt{device assist} one-shotted this secret phrase, and I am pleasantly surprised.
When I first used a BBS in 1990, the SYSOP (my friend's older brother) assigned me the 
handle ``Burger Master''. I hadn't thought of this in years.}

\begin{verbatim}
    sniff 216 tilt 139 fat 230 patient 228 same 87 burger 13 master
\end{verbatim}

To initiate the key exchange protocol, either the user enters $s_2$ on device $D_1$
or $s_1$ on device $D_2$. In both cases, the message flow is as follows:

\begin{center}
\begin{tikzpicture}[>=stealth]
  \node (d1) at (0,6) {$D_1$ (provisioner)};
  \node (d2) at (6,6) {$D_2$ (provisionee)};

  \draw[->] ($(d1)+(0,-1)$) -- node[above] {[start]} ($(d2)+(0,-1)$);
  \draw[->] ($(d2)+(0,-2)$) -- node[above] {hello: $k_2$, $n_2$} ($(d1)+(0,-2)$);
  \draw[->] ($(d1)+(0,-3)$) -- node[above] {please sign: link $l$, token $t$} ($(d2)+(0,-3)$);
  \draw[->] ($(d2)+(0,-4)$) -- node[above] {please counter-sign: link $l$} ($(d1)+(0,-4)$);
  \draw[->] ($(d1)+(0,-5)$) -- node[above] {done} ($(d2)+(0,-5)$);
  
  \draw[dashed] ($(d1)+(0,-.5)$) -- ($(d1)+(0,-5.5)$);
  \draw[dashed] ($(d2)+(0,-.5)$) -- ($(d2)+(0,-5.5)$);
\end{tikzpicture}
\end{center}

The first message, ``start'', is optional and only needed in the case that $s_2$
is entered on device $D_1$. In the ``hello'' message, the provisionee sends its
new key and desired device name over to the provisioner. The provisioner then
makes a sigchain link, $l$, and in the ``please sign'' message, asks the
provisionee to sign it with $k_2$, the new device key. The provisoner also
includes token $t$ so the provisionee can load the user's sigchain from the
server. In the ``please counter-sign'' message, the provisionee returns the
signed link and asks the provisioner sign it a second time with $k_1$, $D_1$'s
device key. Finally, the provisioner can post the new signed sigchain link $l$
to the server, including encryption of the latest PUK for $k_2$ with $l$. Once
the provisionee receives the ``done'' message, it can load the user's PUKs from
the server, and decrypt them with $k_2$.

Though messages between $D_1$ and $D_2$ could use interesting local peer-to-peer
protocols, we employ a simpler, more reliable strategy. The FOKS server proxies
all of these messages. One device sends a message, while the other polls for the
next message in the sequence. Let $s^{*}$ be the session key that was input on
the other device. Both devices encrypt all messages send to the server with the
session key $s^{*}$, using authenticated encryption.

Some researchers~\cite{ncc2019} have suggested using a passphrase-authenticated
key exchange (PAKE) rather than this simple $s_1$ / $s_2$ mechanism. The
observation is that the secret phrases, which users have to type until
smart-phone apps are built, are quite long and could be much shorter with PAKEs.
We considered these constructions but rejected them for FOKS, since we are
concerned the PAKEs can be easily DOSed. That is, the provisionee $D_2$ is not
authenticated to the server since the user hasn't logged in on $D_2$ yet; this
login happens naturally as a result of the provisioning process. Thus, there is
nothing to stop an attacker from targeting a user and entering bad PAKE codes
before the legimiate user can enter the correct code. Such an attack would not
break the integrity of the protocol, but could prevent the user from ever
successfully provisioning.

Note that several of these provisioning sessions can happen concurrently on the
same the server. $D_1$ and $D_2$, with the server's assistance, must separate
their messages from other currently active clients.  They therefore tag each
message in the exchange with the channel identifier $H(s^{*})$, where $H$ is a
one-way function like SHA2. This channel identifier is unguessable for 
any malicious clients who do not know $s^{*}$, and will clearly be unique
across all device pairs.

\subsubsection{\Yubi -to-Device and Device-to-\Yubi }

Most of the protocol in Section~\ref{sec:kex} can be skipped in the case
of either provisioning a regular device (a computer or a phone) with a \yubi ,
or vice versa. No communication needs to bounce off the server, as the device
and the \yubi{} can comunicate directly via the local machine. The crux of 
the protocol, however, remains. For a \yubi{} provisioning a new device,
the device makes the new link, the device signs the link, and the \yubi{} 
countersigns it. Then the device posts the link (and encrypted PUK keys)
to the server. And vice-versa for a device adding a new \yubi . 

\subsection{Teams}
\label{sec:teams}

We covered much of how teams work in Section~\ref{sec:sigchains}, largely by
analogy to users and devices. There are, however, some important differences,
which we cover here in more detail.

\subsubsection{Cross-Server Teams}

As described in Section~\ref{sec:sigchains}, teams are composed of parties
that can span multiple federated servers. A team has a home server, which 
hosts its public keys, encrypted secret keys, sigchain, and Merkle Tree.
An importantly, all the admins and owners --- those who have the ability
to change the team --- must be on the same home server. However, team readers
can join the team from across the Internet.

Because readers can be local or remote, important team protocols, like addition
and removal, must work with more generality, as we cannot assume that the reader
and the team have the same home server. Morever, we cannot assume much
cooperation among independently administered servers under our thread model
(see Section~\ref{sec:threatmodel}).

\subsubsection{Cycle Avoidance}
\label{sec:team-index-range}

One problem in particular the presents itself immediately: potential cycles.
Imagine a simple case, with three hosts $h_1$, $h_2$ and $h_3$, and three teams
on those host, respectively, $t_1$, $t_2$ and $t_3$. If $t_1$ adds $t_2$ as a
reader, $t_2$ adds $t_3$ as a reader, and $t_3$ adds $t_1$ as a reader, there is
now a cycle in the team membership graph. That cycles are bad is not immediately
obvious, but we must consider what happens in a rekey scenario.

Imagine at the start of the sequence, team $t_1$ consists of two owners --- call
then $u$ and $v$ --- and no other members. Team $t_2$ consists of a single owner
$x$, and team $t_3$ consists a single owner $y$. Focus on user $v$, who will
eventually be removed.  At the start $v$ has access to $t_1$'s reader PTK at
generation 1, call it $k^{1}_{1}$.  Next, $x$ adds the readers of $t_1$ to $t_2$
as readers. As a result, $v$ gets access via $k_1^{1}$ to $t_2$'s reader PTK,
call it $k_2^{1}$. Next, user $y$ adds the readers of $t_2$ to $t_3$ as readers,
giving $v$ access to $t_3$'s PTK $k_3^{1}$ transitively via $k_1^1$ and $k_2^1$.
Finally, $u$ completes the cycle, adding the readers of $t_3$ to $t_1$ as readers.

Everything up until now is working as planned, but now consider what happens when
$u$ removes $v$ from $t_1$. What should happen is that all 3 teams should 
rotate so that $v$ loses access to their most recent reader PTKs.





In the case of an cyclic team graph,
unfortunately, there is no ``fixed point'' during rekeying. $t_1$, $t_2$ and
$t_3$ can rotate keys indefinitely without getting to a configuration in which a
removed party doesn't have access to new keys. See
Section~\ref{sec:removal-keys} for more details.




\subsubsection{Invitation Sequence}

\subsection{Key Rotations}
\label{sec:clkr}

\subsubsection{Removal Keys}
\label{sec:removal-keys}

\subsection{Cryptographic Primitives}
\label{sec:cryptography}

\subsubsection{Hashing and MAC'ing}

\subsubsection{Key Derivation}

\subsubsection{\Yubis}

\subsubsection{PQ-KEM and PIV Support}

\subsubsection{High-Entropy Secret Phrase}
\label{sec:hesp}

\subsection{Privacy}

\subsubsection{Blinding and Commitments}
\label{sec:commitments}

\subsubsection{Sigchain Visibility and Permissions}
\label{sec:sigchain-viz}

\subsection{Secret Key Management}

\subsubsection{Secure Enclaves}

\subsubsection{Passphrase-based Management}
\label{sec:passphrase}

\subsection{Beacon Server}
